import java.security.SecureRandom;

import javax.swing.JProgressBar;


public class EAES {
	public static char[][] S_BLOCK = {
	    {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
	    {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
	    {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
	    {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
	    {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
	    {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
	    {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
	    {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
	    {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
	    {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
	    {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
	    {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
	    {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
	    {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
	    {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
	    {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}
	 };
	public static char[][] S_IBLOCK= {
		{0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},
	    {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},
	    {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},
	    {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},
	    {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},
	    {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},
	    {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},
	    {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},
	    {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},
	    {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},
	    {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},
	    {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},
	    {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},
	    {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},
	    {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},
	    {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}
	};
	public static char[][] M_BLOCK = {
		{0x02, 0x03, 0x01, 0x01},
		{0x01, 0x02, 0x03, 0x01},
		{0x01, 0x01, 0x02, 0x03},
		{0x03, 0x01, 0x01, 0x02}
	};
	public static char[][] M_IBLOCK = {
		{0x0E, 0x0B, 0x0D, 0x09},
		{0x09, 0x0E, 0x0B, 0x0D},
		{0x0D, 0x09, 0x0E, 0x0B},
		{0x0B, 0x0D, 0x09, 0x0E}
	};
	public static char[][] E_BLOCK = {
		{0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35}, 
		{0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA}, 
		{0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31}, 
		{0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD}, 
		{0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88}, 
		{0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A}, 
		{0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3}, 
		{0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0}, 
		{0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41}, 
		{0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75}, 
		{0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80}, 
		{0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54}, 
		{0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA}, 
		{0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E}, 
		{0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17}, 
		{0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01}
	};
	public static char[][] L_BLOCK = {
		{0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1A, 0xC6, 0x4B, 0xC7, 0x1B, 0x68, 0x33, 0xEE, 0xDF, 0x03},
		{0x64, 0x04, 0xE0, 0x0E, 0x34, 0x8D, 0x81, 0xEF, 0x4C, 0x71, 0x08, 0xC8, 0xF8, 0x69, 0x1C, 0xC1},
		{0x7D, 0xC2, 0x1D, 0xB5, 0xF9, 0xB9, 0x27, 0x6A, 0x4D, 0xE4, 0xA6, 0x72, 0x9A, 0xC9, 0x09, 0x78},
		{0x65, 0x2F, 0x8A, 0x05, 0x21, 0x0F, 0xE1, 0x24, 0x12, 0xF0, 0x82, 0x45, 0x35, 0x93, 0xDA, 0x8E},
		{0x96, 0x8F, 0xDB, 0xBD, 0x36, 0xD0, 0xCE, 0x94, 0x13, 0x5C, 0xD2, 0xF1, 0x40, 0x46, 0x83, 0x38},
		{0x66, 0xDD, 0xFD, 0x30, 0xBF, 0x06, 0x8B, 0x62, 0xB3, 0x25, 0xE2, 0x98, 0x22, 0x88, 0x91, 0x10},
		{0x7E, 0x6E, 0x48, 0xC3, 0xA3, 0xB6, 0x1E, 0x42, 0x3A, 0x6B, 0x28, 0x54, 0xFA, 0x85, 0x3D, 0xBA},
		{0x2B, 0x79, 0x0A, 0x15, 0x9B, 0x9F, 0x5E, 0xCA, 0x4E, 0xD4, 0xAC, 0xE5, 0xF3, 0x73, 0xA7, 0x57},
		{0xAF, 0x58, 0xA8, 0x50, 0xF4, 0xEA, 0xD6, 0x74, 0x4F, 0xAE, 0xE9, 0xD5, 0xE7, 0xE6, 0xAD, 0xE8},
		{0x2C, 0xD7, 0x75, 0x7A, 0xEB, 0x16, 0x0B, 0xF5, 0x59, 0xCB, 0x5F, 0xB0, 0x9C, 0xA9, 0x51, 0xA0},
		{0x7F, 0x0C, 0xF6, 0x6F, 0x17, 0xC4, 0x49, 0xEC, 0xD8, 0x43, 0x1F, 0x2D, 0xA4, 0x76, 0x7B, 0xB7},
		{0xCC, 0xBB, 0x3E, 0x5A, 0xFB, 0x60, 0xB1, 0x86, 0x3B, 0x52, 0xA1, 0x6C, 0xAA, 0x55, 0x29, 0x9D},
		{0x97, 0xB2, 0x87, 0x90, 0x61, 0xBE, 0xDC, 0xFC, 0xBC, 0x95, 0xCF, 0xCD, 0x37, 0x3F, 0x5B, 0xD1},
		{0x53, 0x39, 0x84, 0x3C, 0x41, 0xA2, 0x6D, 0x47, 0x14, 0x2A, 0x9E, 0x5D, 0x56, 0xF2, 0xD3, 0xAB},
		{0x44, 0x11, 0x92, 0xD9, 0x23, 0x20, 0x2E, 0x89, 0xB4, 0x7C, 0xB8, 0x26, 0x77, 0x99, 0xE3, 0xA5},
		{0x67, 0x4A, 0xED, 0xDE, 0xC5, 0x31, 0xFE, 0x18, 0x0D, 0x63, 0x8C, 0x80, 0xC0, 0xF7, 0x70, 0x07}
	};
	public static char[][] ByteSub(char[][] input){
		for(int i=0;i<input.length;i++){
			for(int j=0;j<input.length;j++){//4x4
				int val = input[i][j];
				int b1 = val/16;
				int b2 = val%16;
				input[i][j] = S_BLOCK[b1][b2];
			}
		}
		return input;
	}
	public static char[][] ByteSubD(char[][] input){
		for(int i=0;i<input.length;i++){
			for(int j=0;j<input.length;j++){//4x4
				int val = input[i][j];
				int b1 = val/16;
				int b2 = val%16;
				input[i][j] = S_IBLOCK[b1][b2];
			}
		}
		return input;
	}
	public static char[][] shiftRow(char[][] input){
		for(int i=0;i<input.length;i++){
			for(int j=i;j>0;j--){//<< i
				char temp = input[i][0];
				input[i][0] = input[i][1];
				input[i][1] = input[i][2];
				input[i][2] = input[i][3];
				input[i][3] = temp;
			}
		}
		return input;
	}
	public static char[][] shiftRowD(char[][] input){
		for(int i=0;i<input.length;i++){
			for(int j=i;j>0;j--){//>> i
				char temp = input[i][3];
				input[i][3] = input[i][2];
				input[i][2] = input[i][1];
				input[i][1] = input[i][0];
				input[i][0] = temp;
			}
		}
		return input;
	}
	//========================
	public static char[][] diffusion(char[][] input){
		for(int j=0;j<input.length;j++){
			char b1 = input[0][j];
			char b2 = input[1][j];
			char b3 = input[2][j];
			char b4 = input[3][j];
			input[0][j] = (char)((galoisMultiplication(b1,M_BLOCK[0][0]))^(galoisMultiplication(b2,M_BLOCK[0][1]))^(galoisMultiplication(b3,M_BLOCK[0][2]))^(galoisMultiplication(b4,M_BLOCK[0][3])));
			input[1][j] = (char)((galoisMultiplication(b1,M_BLOCK[1][0]))^(galoisMultiplication(b2,M_BLOCK[1][1]))^(galoisMultiplication(b3,M_BLOCK[1][2]))^(galoisMultiplication(b4,M_BLOCK[1][3])));
			input[2][j] = (char)((galoisMultiplication(b1,M_BLOCK[2][0]))^(galoisMultiplication(b2,M_BLOCK[2][1]))^(galoisMultiplication(b3,M_BLOCK[2][2]))^(galoisMultiplication(b4,M_BLOCK[2][3])));
			input[3][j] = (char)((galoisMultiplication(b1,M_BLOCK[3][0]))^(galoisMultiplication(b2,M_BLOCK[3][1]))^(galoisMultiplication(b3,M_BLOCK[3][2]))^(galoisMultiplication(b4,M_BLOCK[3][3])));
		}
		return input;
	}
	public static char[][] diffusionD(char[][] input){
		for(int j=0;j<input.length;j++){
			char b1 = input[0][j];
			char b2 = input[1][j];
			char b3 = input[2][j];
			char b4 = input[3][j];
			input[0][j] = (char)((galoisMultiplication(b1,M_IBLOCK[0][0]))^(galoisMultiplication(b2,M_IBLOCK[0][1]))^(galoisMultiplication(b3,M_IBLOCK[0][2]))^(galoisMultiplication(b4,M_IBLOCK[0][3])));
			input[1][j] = (char)((galoisMultiplication(b1,M_IBLOCK[1][0]))^(galoisMultiplication(b2,M_IBLOCK[1][1]))^(galoisMultiplication(b3,M_IBLOCK[1][2]))^(galoisMultiplication(b4,M_IBLOCK[1][3])));
			input[2][j] = (char)((galoisMultiplication(b1,M_IBLOCK[2][0]))^(galoisMultiplication(b2,M_IBLOCK[2][1]))^(galoisMultiplication(b3,M_IBLOCK[2][2]))^(galoisMultiplication(b4,M_IBLOCK[2][3])));
			input[3][j] = (char)((galoisMultiplication(b1,M_IBLOCK[3][0]))^(galoisMultiplication(b2,M_IBLOCK[3][1]))^(galoisMultiplication(b3,M_IBLOCK[3][2]))^(galoisMultiplication(b4,M_IBLOCK[3][3])));
		}
		return input;
	}
	public static char galoisMultiplication(char A, char B){
		if(A==0 || B==0){
			return 0;
		}
		if(A==1){
			return B;
		}
		if(B==1){
			return A;
		}
		int Llookups = lookupL(A)+lookupL(B);
		if(Llookups>255){
			Llookups-=255;
		}
		return lookupE((char)Llookups);
	}
	public static char lookupL(char I){
		int b1 = I/16;
		int b2 = I%16;
		return L_BLOCK[b1][b2];
	}
	public static char lookupE(char I){
		int b1 = I/16;
		int b2 = I%16;
		return E_BLOCK[b1][b2];
	}
	//==============================
	public static char[] rotWord(char[] stream){//rotate stream << 1
		char temp = stream[0];
		stream[0] = stream[1];
		stream[1] = stream[2];
		stream[2] = stream[3];
		stream[3] = temp;
		return stream;
	}
	public static char[] subWord(char[] stream){
		for(int i=0;i<stream.length;i++){
			int b1 = stream[i]/16;
			int b2 = stream[i]%16;
			stream[i] = S_BLOCK[b1][b2];
		}
		return stream;
	}
	public static char rcon(int round, int keysize){
		int index = round/(keysize/4)-1;
		switch(index){
			case 0:
				return 0x01;
			case 1:
				return 0x02;
			case 2:
				return 0x04;
			case 3:
				return 0x08;
			case 4:
				return 0x10;
			case 5:
				return 0x20;
			case 6:
				return 0x40;
			case 7:
				return 0x80;
			case 8:
				return 0x1B;
			case 9:
				return 0x36;
			case 10:
				return 0x6C;
			case 11:
				return 0xD8;
			case 12:
				return 0xAB;
			case 13:
				return 0x4D;
			case 14:
				return 0x9A;
		}
		return 0x00;
	}
	public static char[] EK(char[] expandkey, int index){
		char[] toRet =  new char[4];
		toRet[0] = expandkey[index+0];
		toRet[1] = expandkey[index+1];
		toRet[2] = expandkey[index+2];
		toRet[3] = expandkey[index+3];
		return toRet;
	}
	public static char[] K(char[] key, int index){
		char[] toRet =  new char[4];
		toRet[0] = key[index+0];
		toRet[1] = key[index+1];
		toRet[2] = key[index+2];
		toRet[3] = key[index+3];
		return toRet;
	}
	public static char[] keyExpansion(char[] key){
		char[] exp = null;
		char[] sub = null;
		if(key.length==16){
			exp = new char[176];
			//intializer
			for(int i=0;i<key.length;i++){
				exp[i] = key[i];
			}
			
			for(int round=4;round<44;round++){
				/*if(round==4){
					sub = XOR4(XORR(subWord(rotWord(EK(exp,(round-1)*4))),rcon(round,16)),EK(exp,(round-4)*4));
				}*/
				if(round%4==0){
					sub = XOR4(XORR(subWord(rotWord(EK(exp,(round-1)*4))),rcon(round,16)),EK(exp,(round-4)*4));
				}
				else{
					sub = XOR4(EK(exp,(round-1)*4),EK(exp,(round-4)*4));
				}
				for(int j=0;j<4;j++){
					exp[j+4*round] = sub[j];
				}
			}
		}
		else if(key.length==24){
			exp = new char[176];
		}
		else if(key.length==32){
			exp = new char[176];
		}
		return exp;
	}
	public static char[] XOR4(char[] A,char[] B){
		char[] C = new char[4];
		C[0] = (char)(A[0]^B[0]);
		C[1] = (char)(A[1]^B[1]);
		C[2] = (char)(A[2]^B[2]);
		C[3] = (char)(A[3]^B[3]);
		return C;
	}
	public static char[] XORR(char[] A,char B){
		char[] C = new char[4];
		C[0] = (char)(A[0]^B);
		C[1] = (char)(A[1]^0);
		C[2] = (char)(A[2]^0);
		C[3] = (char)(A[3]^0);
		return C;
	}
	public static char[][] addRoundKey(char[][] state, char[] exp, int iter){
		iter++;
		for(int i=0;i<16;i++){
			state[i%4][i/4] = (char)(state[i%4][i/4]^exp[16*iter+i]);
		}
		return state;
	}
	public static char[][] addRoundKeyD(char[][] state, char[] exp, int iter){
		iter++;
		for(int i=0;i<16;i++){
			state[i%4][i/4] = (char)(state[i%4][i/4]^exp[16*(10-iter)+i]);
		}
		return state;
	}
	public static char[][] initalizeState(char[] block){
		char[][] state = new char[4][4];
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++){
				state[i][j] = block[i+j*4];
			}
		}
		return state;
	}
	public static char[] linearize(char[][] input){
		char[] toret = new char[input.length*input.length];
		for(int i=0; i<toret.length;i++){
			toret[i] = input[i%4][i/4];
		}
		return toret;
	}
	public static char[] AES_ENC_BLOCK(char[] data, char[] key){
		char[] exp = keyExpansion(key);
		char[][] state = initalizeState(data);
		state = addRoundKey(state,exp,-1);
		int len = (key.length==16? 9:(key.length==24? 11:13));
		for(int r=0;r<len;r++){
			state = addRoundKey(diffusion(shiftRow(ByteSub(state))),exp,r);
		}
		state = addRoundKey(shiftRow(ByteSub(state)),exp,len);
		return linearize(state);
	}
	public static char[] AES_DEC_BLOCK(char[] data, char[] key){
		char[] exp = keyExpansion(key);
		char[][] state = initalizeState(data);
		state = addRoundKeyD(state,exp,-1);
		int len = (key.length==16? 9:(key.length==24? 11:13));
		for(int r=0;r<len;r++){
			state = diffusionD(addRoundKeyD(ByteSubD(shiftRowD(state)),exp,r));
		}
		state = addRoundKeyD(ByteSubD(shiftRowD(state)),exp,len);
		return linearize(state);
	}
	public static char[] AES_DEC2_BLOCK(char[] data, char[] key){
		char[] exp = keyExpansion(key);
		char[][] state = initalizeState(data);
		int len = (key.length==16? 9:(key.length==24? 11:13));
		state = addRoundKey(state,exp,len);
		for(int r=(len-1);r>-1;r--){
			state = diffusionD(addRoundKey(ByteSubD(shiftRowD(state)),exp,r));
		}
		state = addRoundKey(ByteSubD(shiftRowD(state)),exp,-1);
		return linearize(state);
	}
	public static char[] getBlock(char[] data,int offset){
		char[] block = new char[16];
		if((offset*16+16)>data.length){
			for(int i=offset*16;i<data.length;i++){
				block[i%16] = data[i];
			}
			for(int i=data.length;i<(offset*16+16);i++){
				block[i%16] = 0;
			}
		}
		else{
			for(int i=offset*16;i<(offset*16+16);i++){
				block[i%16] = data[i];
			}
		}
		return block;
	}
	public static void setBlock(char[] data,int offset,char[] newdata){
		for(int i=offset*16;(i<(offset*16+16))&&(i<data.length);i++){
			data[i] = newdata[i%16];
		}
	}
	public static char[] AES_ENC_ECB(char[] data, char[] key,JProgressBar prog, double piece){
		int bnum;
		char[] enck;
		if(data.length%16==0){
			bnum = data.length/16;
			enck = new char[data.length];
		}
		else{
			bnum = data.length/16+1;
			enck = new char[data.length+(16-data.length%16)+1];
			enck[enck.length-1] = (char)(16-data.length%16);
		}
		for(int i=0;i<bnum;i++){
			setBlock(enck,i,AES_ENC_BLOCK(getBlock(data,i),key));
			prog.setValue((int)((i+1)*piece));
		}
		return enck;//TODO
	}
	public static char[] AES_DEC_ECB(char[] data, char[] key){
		int bnum;
		char[] deck;
		
		if(data.length%16==0){
			bnum = data.length/16;
			deck = new char[data.length];
		}
		else{
			bnum = data.length/16+1;
			deck = new char[data.length-(data[data.length-1]+1)];
		}
		for(int i=0;i<bnum;i++){
			setBlock(deck,i,AES_DEC_BLOCK(getBlock(data,i),key));
		}
		return deck;//TODO
	}
	public static char[] AES_ENC(char[] data, char[] key, int mode,JProgressBar prog, double piece){
		printKey(data);
		printKey(key);
		char[] result = AES_ENC_ECB(data,key,prog,piece);
		printKey(result);
		return result;
	}
	public static char[] GEN_KEY(){
		SecureRandom random = new SecureRandom();
	    char chars[] = new char[16];
	    for(int i=0;i<chars.length;i++){
	    	chars[i] = (char)(Math.abs(random.nextInt())%256);
	    }
	    return chars;
	}
	public static void printState(char[][] state){
		for(int i=0;i<state.length;i++){
			for(int j=0;j<state.length;j++){
				System.out.print("0x"+Integer.toHexString(state[i][j])+"\t");
			}
			System.out.println();
		}
	}
	public static void printKey(char[] key){
		for(int i=0;i<key.length;i++){
			if(i%8==0){
				System.out.println();
			}
			System.out.print("0x"+Integer.toHexString(key[i])+"\t");
		}
		System.out.println();
	}
	public static String stringKey(char[] key){
		String toRet = "";
		for(int i=0;i<key.length;i++){
			if(i%8==0){
				toRet+="\n";
			}
			toRet+=("0x"+Integer.toHexString(key[i])+"\t");
		}
		toRet+="\n";
		return toRet;
	}
	/*
	public static void main(String[] args) {
		char[] data = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',0x00};
		char[] data2= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','A','B','C','D','E','F','G','H','I','J','K','L','M'};
		char[] key  = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P'};
		printKey(AES_DEC_ECB(AES_ENC_ECB(data,key),key));
		printKey(AES_DEC_ECB(AES_ENC_ECB(data2,key),key));
		printKey(GEN_KEY());
	}*/

}